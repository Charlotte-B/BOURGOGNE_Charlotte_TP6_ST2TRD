Exercise 1

1. What is clean code? What is the role played by refactoring one’s code?

Refactoring makes it possible to transform a sales code into clean code.
Clean code should be easily understood. It must be able to be read and improved by a developer other than the person who wrote it. 
With understandability comes readability, ease of change, extensibility and maintainability.
The main rules of clean code:
- Contains no duplication
- Contains a minimal number of classes and other moving parts
- Pass all the tests


2. Do you think you can “over-refactor” and do too much? How?

I think it's possible to over-refactor a code. A code is almost never "too clean" and following the four elements of simple design shouldn't lead to over-engineering.
We reach the over-refactoring of a code when the developer has used all the possible design patterns that meet the functionalities of the code.
In some cases, over-refactoring is irrelevant. 
When a code is clean enough, it is not necessarily useful to add design patterns. 
Because by dint of over-refactoring a code, certain design patterns can slow down the solution and increase its costs.
Each design decision must be considered individually. Only use a design pattern if its benefits outweigh its costs.


3. What is a code smell? Why should you bother?

Code smell indicates poor fundamental design principles that diminish the overall quality of the code, usually indicates a deeper problem.
They are not bugs or errors in the sense that they are not officially bad code and do not prevent the implementation of the program, although code smell can certainly increase the risk of bugs and failures in the code. 
And prevent its execution.

Using code smell detection tools and subjecting code to short, controlled refactoring sessions, you can go beyond the initial impact of code smell and uncover the problem deeper within the software. 
Code smell can often be key to discovering when to refactor and what refactoring techniques to use.


4. Can you identify a few code smells in the original GuildedRose?

We find as smell code:
- Bloaters (constructs are too long)
- Object-Orientation Abusers (Inappropriate Static)
- Dispensables (Duplicate Code, Lazy Class, Data Class)
- Change Preventers (Shotgun Surgery = we need to touch multiple parts of the code to make a behavior change)
- Obfuscators (Poor Names, Inconsistency...)
- No Test Smells


5. What are some refactoring techniques you could have used in the GuildedRose?
(image google tableau)
